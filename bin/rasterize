#!/usr/bin/env python
"""Create a 3-D rasterized georeferenced model composed of uniform grids.
"""

import os
import sys
import logging
import argparse
import configparser
import subprocess
import math
from abc import ABC

import h5py
import numpy

def string_to_list(list_string):
    """Convert list as string into a list of objects.

    Args:
        list_string (str):
            List as string, e.g., "[a, b, c]"

    Returns:
        List of objects, e.g., ["a", "b", "c"]
    """
    values = [value.strip() for value in list_string[1:-1].split(",")]
    return values


def length_units_to_scale(name):
    value = 1.0
    if name in ["m", "meter", "meters"]:
        value = 1.0
    elif name in ["km", "kilometer", "kilometers"]:
        value = 1000.0
    elif name in ["ft", "feet"]:
        value = 0.3048
    else:
        raise ValueError("Unknown units '{}' for topography elevation.".format(name))
    return value
    

class Block(object):
    """Block of regular logically gridded points.
    """

    def __init__(self, name, config):
        """Constructor.

        Args:
            name (str)
                Name of block.
            config (dict)
                Block parameters as dictionary.
                Keys:
                    resolution_horiz: horizontal resolution (m)
                    resolution_vert: vertical resolution (m)
                    z_top: Elevation of top of block (m)
                    z_bot: Elevation of bottom of block (m)
                    z_top_offset: Vertical offset of top set of points below top of block (m)
        """
        self.name = name
        self.res_horiz = float(config["resolution_horiz"])
        self.res_vert = float(config["resolution_vert"])
        self.z_top = float(config["z_top"])
        self.z_bot = float(config["z_bot"])
        self.z_top_offset = float(config["z_top_offset"])
        return

    def get_dims(self, domain):
        """Get number of points in block along each dimension.

        Args:
            domain (Model)
                Model domain.
        
        Returns:
            Array of points in block (Nx*Ny*Nz, 3)
        """
        num_x = 1 + int(domain.dim_x / self.res_horiz)
        num_y = 1 + int(domain.dim_y / self.res_horiz)
        num_z = 1 + int((self.z_top-self.z_bot) / self.res_vert)
        return (num_x, num_y, num_z)
    
    def generate_points(self, domain):
        """Generate grid of points in block.

        Args:
            domain (Model)
                Model domain.

        Returns:
            3D array (Nx*Ny*Nz,3) of point locations in block.
        """
        (num_x, num_y, num_z) = self.get_dims(domain)
        logger = logging.getLogger(__name__)
        logger.info("Block '{}' contains {} points ({} x {} x {}).".format(
            self.name, num_x*num_y*num_z, num_x, num_y, num_z,))

        x1 = numpy.linspace(0.0, self.res_horiz*(num_x-1), num_x)
        y1 = numpy.linspace(0.0, self.res_horiz*(num_y-1), num_y)
        z1 = numpy.linspace(0.0, self.res_vert*(num_z-1), num_z)
        x,y,z = numpy.meshgrid(x1, y1, z1)

        domain_top = 0.0
        domain_bot = -domain.dim_z
        if domain.topography is not None:
            topoG = domain.topography.elevation
            for iz in range(z.shape[-1]):
                z[:,:,iz] = domain_bot + (topoG-domain_bot)/(domain_top-domain_bot)*(self.z_top - z[:,:,iz] - domain_bot)

            # Move top points down
            z[:,:,0] += self.z_top_offset
        else:
            z = self.z_top - z

        xyzG = numpy.stack((x, y, z), axis=3)
        xyzP = numpy.zeros(xyzG.shape)
        azRad = domain.y_azimuth * math.pi / 180.0
        xyzP[:,:,:,0] = domain.origin_x + xyzG[:,:,:,0]*math.cos(azRad) + xyzG[:,:,:,1]*math.sin(azRad)
        xyzP[:,:,:,1] = domain.origin_y - xyzG[:,:,:,0]*math.sin(azRad) + xyzG[:,:,:,1]*math.cos(azRad)
        xyzP[:,:,:,2] = xyzG[:,:,:,2]
        return xyzP

class Topography(object):
    """Surface topography.
    """

    def __init__(self, config):
        """Constructor.

        Args:
           config (dict)
             True if use of topography is enabled, False otherwise.
             Keys:
                 use_topography: Model uses topography
                 resolution_horiz: Horizontal resolution in m
        """
        self.elevation = None
        self.enabled = bool(config["use_topography"])
        self.resolution_horiz = float(config["resolution_horiz"]) if self.enabled else None
        return

    def set_elevation(self, elev):
        """Set topography values.

        Args:
            elev (numpy.array)
                Numpy array [Nx*Ny] with elevation at points.
        """
        if not self.enabled:
            return
        
        self.elevation = elev
        return

    def generate_points(self, domain):
        """Generate points for topography.

        Args:
            domain (Model)
                Model with topography.
        Returns:
            2D array (Nx*Ny,2) of point locations for ground surface.
        """
        dx = self.resolution_horiz

        num_x = 1 + int(domain.dim_x / dx)
        num_y = 1 + int(domain.dim_y / dx)
        logger = logging.getLogger(__name__)
        logger.info("Topography contains {} points ({} x {}).".format(
            num_x*num_y, num_x, num_y))

        x1 = numpy.linspace(0.0, dx*(num_x-1), num_x)
        y1 = numpy.linspace(0.0, dx*(num_y-1), num_y)
        x,y = numpy.meshgrid(x1, y1)
        z = numpy.zeros(x.shape)

        xyzG = numpy.stack((x, y, z), axis=2)
        xyzP = numpy.zeros(xyzG.shape)
        azRad = domain.y_azimuth * math.pi / 180.0
        xyzP[:,:,0] = domain.origin_x + xyzG[:,:,0]*math.cos(azRad) + xyzG[:,:,1]*math.sin(azRad)
        xyzP[:,:,1] = domain.origin_y - xyzG[:,:,0]*math.sin(azRad) + xyzG[:,:,1]*math.cos(azRad)
        return xyzP
    

class HDF5Storage(object):
    """HDF5 file for storing gridded model.
    """
    DOMAIN_ATTRS = (
        "description",
        "version",
        "projection",
        "origin_x",
        "origin_y",
        "y_azimuth",
        "data_values",
        "data_units",
        "dim_x",
        "dim_y",
        "dim_z",
    )
    TOPOGRAPHY_ATTRS = (
        "resolution_horiz",
    )
    BLOCK_ATTRS = (
        "ressolution_horiz",
        "resolution_vert",
        "z_top",
    )    
    
    def __init__(self, filename):
        """Constructor.

        Args:
            filename (str):
                Name for HDF5 file
        """
        self.filename = filename
        return

    def save_domain(self, domain):
        """Write domain attributes to HDF5 file.

        Args:
            domain (Model):
                Model domain.
        """
        h5 = h5py.File(self.filename, "a")
        attrs = h5.attrs
        for attr in self.DOMAIN_ATTRS:
            attrs[attr] = getattr(domain, attr)
        h5.close()
        return

    def save_topography(self, topography):
        """Write topography to HDF5 file.

        Args:
            topography (Topography)
                Surface topography.
        """
        h5 = h5py.File(self.filename, "a")
        topo_dataset = h5.create_dataset("topography", data=topography.elevation)
        attrs = topo_dataset.attrs
        for attr in self.TOPOGRAPHY_ATTRS:
            attrs[attr] = getattr(topography, attr)
        h5.close()
        return

    def load_topography(self, topography):
        """Load topography from HDF5 file.

        Args:
            topography (Topography)
                Surface topography.
        """
        h5 = h5py.File(self.filename, "r")
        topo_dataset = h5["topography"]
        topography.elevation = topo_dataset[:]
        attrs = topo_dataset.attrs
        for attr in self.TOPOGRAPHY_ATTRS:
            if getattr(topography, attr) != attrs[attr]:
                raise ValueError("Inconsistency in topography attribute '{}': config value: {}, value from model: {}".format(
                    attr, getattr(topography, attr), attrs[attr]))
        h5.close()        
        return
    
    def save_block(self, block, data):
        import pdb; pdb.set_trace()
        h5 = h5py.File(self.filename, "a")
        block_dataset = h5.create_dataset(block.name, data=data)
        attrs = block_dataset.attrs
        for attr in self.BLOCK_ATTRS:
            attrs[attr] = getattr(block, attr)
        h5.close()
        return


class Model(ABC):
    """Georeferenced model composed of logical grids, potentially warped by topography.
    """
    
    def __init__(self, config):
        """Constructor.
        """
        self.topography = None
        self.blocks = []

        self.initialize(config)
        return

    def initialize(self, config):
        """Setup model, creating blocks.

        Args:
            config (dict)
                Model configuration.
        """
        self.description = config["geomodelgrids"]["description"]
        self.version = config["geomodelgrids"]["version"]
        self.projection = config["coordsys"]["projection"]
        self.origin_x = float(config["coordsys"]["origin_x"])
        self.origin_y = float(config["coordsys"]["origin_y"])
        self.y_azimuth = float(config["coordsys"]["y_azimuth"])
        self.data_values = config["data"]["values"]
        self.data_units = config["data"]["units"]
        self.dim_x = float(config["domain"]["dim_x"])
        self.dim_y = float(config["domain"]["dim_y"])
        self.dim_z = float(config["domain"]["dim_z"])
        
        self.config = config

        self.topography = Topography(config["topography"])
        for name in string_to_list(config["domain"]["blocks"]):
            block = Block(name, config[name])
            self.blocks.append(block)

        self.storage = HDF5Storage(config["geomodelgrids"]["filename"])
        return

    def import_domain(self):
        """Write domain information to storage."""
        self.storage.save_domain(self)
        return
    
    def import_topography(self):
        self.storage.save_topography(self.topography)
        return

    def load_topography(self):
        """Load topography from model file."""
        self.storage.load_topography(self.topography)
        return
    
    def import_block(self, block, values):
        self.storage.save_block(block, values)
        return

    #@abstractmethod
    def query_topography(self, points):
        pass
    
    #@abstractmethod
    def query_values(self, points):
        pass
    

class EarthVisionAPIModel(Model):

    def initialize(config):
        super().initialize(config)

        self._get_faultblocks_zones()
        return

    def _get_faultblocks_zones(self):
        FAULTBLOCK_HEADING = "Fault Block Names"
        ZONE_HEADING = "Zone Names"
        NAME_PATTERN = r"^\[([0-9]+)\]\s([\S]+.+)"

        def _read_names(lines, start):
            id_mapping = {}
            for line in lines[start:]:
            match = re.search(NAME_PATTERN, line.strip())
            if match and len(match.groups()) == 2:
                groups = match.groups()
                id_mapping[groups[1]] = groups[0]
            else:
                break
            return id_mapping

        ev_faces = self.config["earthvision"]["geologic_model"].replace(".seq", ".face")
        cmd = "ev_facedump {ev_faces}".format(ev_faces=ev_faces)
        result = subprocess.run(cmd.split(), cwd=model_dir, env=ev_env)
        lines = result.stdout
        for iline, line in enumerate(lines):
            if line.startswith(FAULTBLOCK_HEADING):
                self.fault_block_ids = _read_names(lines, iline+1)
            if line.startswith(ZONE_HEADING):
                self.zone_ids = _read_names(lines, iline+1)
        return
    
    def query_values(self, points):
        """Query EarthVision model for values at points.

        Args:
            points (numpy.array [Nx,Ny,Nz])
                Numpy array with coordinates of points in model coordinates.
        """
        POINTS_FILENAME = "block_points.dat" # Must have .dat suffix.
        VALUES_FILENAME = "block_values.dat" # Must have .data suffix.
        
        model_dir = os.path.expanduser(self.config["earthvision"]["model_dir"])
        points_abspath = os.path.join(model_dir, POINTS_FILENAME)
        values_abspath = os.path.join(model_dir, VALUES_FILENAME)

        scale = length_units_to_scale(self.config["earthvision"]["xy_units"])
        numpy.savetxt(points_abspath, points.reshape((-1, points.shape[2]))/scale, fmt="%16.8e")

        ev_model = self.config["earthvision"]["geologic_model"]
        cmd = "ev_label -m {ev_model} -o {filename_out} -suppress VolumeIndex {filename_in}".format(
            filename_in=POINTS_FILENAME, filename_out=VALUES_FILENAME, ev_model=ev_model)
        subprocess.run(cmd.split(), cwd=model_dir, env=ev_env)

        converters = {
            0: lambda s: float(s),
            1: lambda s: float(s),
            2: lambda s: float(s),
            3: lambda s: s.strip('"'),
            4: lambda s: s.strip('"'),
        }
        dtype = {
            "names": ("x", "y", "z", "fault_block", "zone"),
            "formats": ("f4", "f4", "f4", "S32", "S32")
        }
        data = numpy.loadtxt("ev_label_out.txt", delimiter="\t", dtype=dtype, converters=converters)
        fault_block_id = numpy.array([self.faultblock_ids[name] for name in data["fault_block"]])
        zone_id = numpy.array([self.zone_ids[name] for name in data["zone"]])
        z_depth = self.topography.elevation - data["z"]
        
        values = numpy.array([self.rules[(fb_id,z_id)](pt['x'],pt['y'],pt_depth) for (pt, fb_id, z_id, pt_depth) in zip(data, fault_block_id, zone_id, z_depth)])
        return values

    def query_topography(self, points):
        """Query EarthVision model for elevation of ground surface at points.

        Args:
            points (numpy.array [Nx,Ny,Nz])
                Numpy array with coordinates of points in model coordinates.
        """
        POINTS_FILENAME = "topography_points.dat" # Must have .dat suffix.
        ELEV_FILENAME = "topography_elev.dat" # Must have .data suffix.
        
        model_dir = os.path.expanduser(self.config["earthvision"]["model_dir"])
        points_abspath = os.path.join(model_dir, POINTS_FILENAME)
        elev_abspath = os.path.join(model_dir, ELEV_FILENAME)
        scale = length_units_to_scale(self.config["earthvision"]["xy_units"])

        numpy.savetxt(points_abspath, points.reshape((-1, points.shape[2]))/scale, fmt="%16.8e")
        
        topo_2grd = self.config["earthvision"]["topography_2grd"]
        ev_env = self.config["earthvision.environment"]
        formula = "{filename_out}<elev> = bakint({ev2grd}, {filename_in}<x>, {filename_in}<y>);".format(
            filename_in=POINTS_FILENAME, filename_out=ELEV_FILENAME, ev2grd=topo_2grd)
        subprocess.run(["ev_fp"], input=formula.encode("utf-8"), cwd=model_dir, env=ev_env)

        elev = numpy.loadtxt(elev_abspath).reshape(points.shape[0:2])
        elev *= length_units_to_scale(self.config["earthvision"]["elev_units"])
        self.topography.set_elevation(elev)

        os.remove(points_abspath)
        os.remove(elev_abspath)        
        return


class App(object):
    """Application for generating a rasterized model.
    """

    def __init__(self):
        """Constructor."""
        self.config = None
        self.model = None
        return

    def main(self, **kwargs):
        """Main entry point.
        """
        args = argparse.Namespace(**kwargs) if kwargs else self._parse_command_line()
        logLevel = logging.DEBUG if args.debug else logging.INFO
        logging.basicConfig(level=logLevel, filename="rasterize.log")
        if args.show_progress:
            self.show_progress = True
        config = self.initialize(args.config)

        if args.show_parameters:
            self.show_parameters(config)
            return
        
        model = EarthVisionAPIModel(config)

        if args.import_domain:
            model.import_domain()

        if args.import_topography:
            if model.topography.enabled:
                points = model.topography.generate_points(model)
                model.query_topography(points)
                model.import_topography()

        if args.import_blocks:
            if model.topography.elevation is None:
                model.load_topography()
            for block in model.blocks:
                points = block.generate_points(model)
                values = model.query_values(points)
                #model.import_block(block, values)
        return
 
    def initialize(self, config_filenames):
        """Set parameters from config file and DEFAULTS.

        Args:
            config_filename (str)
                Name of configuration (INI) file with parameters.
        """
        config = configparser.ConfigParser()
        config.optionxform = str
        for filename in config_filenames.split(","):
            if not os.path.isfile(filename):
                raise IOError("Could not find configuration file '{}'.".format(filename))
            if self.show_progress:
                print("Fetching parameters from {}...".format(filename))
            config.read(filename)

        config = {s: dict(config.items(s)) for s in config.sections()}
        return config
    
    def show_parameters(self, config):
        """Write parameters to stdout.
        """
        parser = configparser.ConfigParser()
        parser.read_dict(config)
        parser.write(sys.stdout)
        return

    def _parse_command_line(self):
        """Parse command line arguments.
        """
        DESCRIPTION = (
            "Application for generating HDF5 file containing blocks of a grid-based model."
            )
        
        parser = argparse.ArgumentParser(description=DESCRIPTION)
        parser.add_argument("--config", action="store", dest="config", required=True)
        parser.add_argument("--show-parameters", action="store_true", dest="show_parameters")
        parser.add_argument("--import-domain", action="store_true", dest="import_domain")
        parser.add_argument("--import-topography", action="store_true", dest="import_topography")
        parser.add_argument("--import-blocks", action="store_true", dest="import_blocks")

        parser.add_argument("--all", action="store_true", dest="all")
        parser.add_argument("--quiet", action="store_false", dest="show_progress", default=True)
        parser.add_argument("--log", action="store", dest="log_filename", default="rasterize.log")
        parser.add_argument("--debug", action="store_true", dest="debug")
        args = parser.parse_args()

        if args.debug:
            logging.basicConfig(level=logging.DEBUG, filename=args.log_filename)
        else:
            logging.basicConfig(level=logging.INFO, filename=args.log_filename)
        return args


# ------------------------------------------------------------------------------
if __name__ == "__main__":
    App().main()


# End of file

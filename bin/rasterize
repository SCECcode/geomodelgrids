#!/usr/bin/env python
"""Create a 3-D rasterized georeferenced model composed of uniform grids.
"""

import os
import sys
import logging
import argparse
import configparser
import math
from abc import ABC

import h5py
import numpy

def string_to_list(list_string):
    """Convert list as string into a list of objects.

    Args:
        list_string (str):
            List as string, e.g., "[a, b, c]"

    Returns:
        List of objects, e.g., ["a", "b", "c"]
    """
    values = [value.strip() for value in list_string[1:-1].split(",")]
    return values


def length_units_to_scale(name):
    value = 1.0
    if name in ["m", "meter", "meters"]:
        value = 1.0
    elif name in ["km", "kilometer", "kilometers"]:
        value = 1000.0
    elif name in ["ft", "feet"]:
        value = 0.3048
    else:
        raise ValueError("Unknown units '{}' for topography elevation.".format(elevation_units))
    return value
    

class Block(object):
    """Block of regular logically gridded points.
    """

    def __init__(self, name, config):
        """Constructor.

        Args:
            name (str)
                Name of block.
            config (dict)
                Block parameters as dictionary.
                Keys:
                    resolution_horiz: horizontal resolution (m)
                    resolution_vert: vertical resolution (m)
                    z_top: Elevation of top of block (m)
                    z_bot: Elevation of bottom of block (m)
                    z_top_offset: Vertical offset of top set of points below top of block (m)
        """
        self.name = name
        self.res_horiz = float(config["resolution_horiz"])
        self.res_vert = float(config["resolution_vert"])
        self.z_top = float(config["z_top"])
        self.z_bot = float(config["z_bot"])
        self.z_top_offset = float(config["z_top_offset"])
        return

    def get_dims(self, domain):
        """Get number of points in block along each dimension.

        Args:
            domain (Model)
                Model domain.
        
        Returns:
            Array of points in block (Nx*Ny*Nz, 3)
        """
        num_x = 1 + int(domain.dim_x / self.res_horiz)
        num_y = 1 + int(domain.dim_y / self.res_horiz)
        num_z = 1 + int((self.z_top-self.z_bot) / self.res_vert)
        return (num_x, num_y, num_z)
    
    def generate_points(self, domain):
        """Generate grid of points in block.

        Args:
            domain (Model)
                Model domain.

        Returns:
            3D array (Nx*Ny*Nz,3) of point locations in block.
        """
        (num_x, num_y, num_z) = self.get_dims(domain)
        logger = logging.getLogger(__name__)
        logger.info("Block '{}' contains {} points ({} x {} x {}).".format(
            name, num_x*num_y*num_z, num_x, num_y, num_z,))

        x1 = numpy.linspace(0.0, self.res_horiz*(num_x-1), num_x)
        y1 = numpy.linspace(0.0, self.res_horiz*(num_y-1), num_y)
        z1 = numpy.linspace(0.0, self.res_vert*(num_z-1), num_z)
        x,y,z = numpy.meshgrid(x1, y1, z1)

        domain_top = 0.0
        domain_bot = -domain.dim_z
        if domain.topography is not None:
            topoG = domain.topography
            z[:,:,:] = domain_bot + (topoG-domain_bot)/(domain_top-domain_bot)*(self.z_top - z[:,:,:] - domain_bot)

            # Move top points down
            z[:,:,0] += self.z_top_offset
        else:
            z = self.z_top - z
        
        xyzG = numpy.vstack((x.ravel(), y.ravel(), z.ravel(),)).transpose()
        xyzP = numpy.zeros(xyzG.shape)
        azRad = y_azimuth * math.pi / 180.0
        xyzP[:,0] = origin_x + xyzG[:,0]*math.cos(azRad) + xyzG[:,1]*math.sin(azRad)
        xyzP[:,1] = origin_y - xyzG[:,0]*math.sin(azRad) + xyzG[:,1]*math.cos(azRad)
        xyzP[:,2] = xyzG[:,2]
        return xyzP

class Topography(object):
    """Surface topography.
    """

    def __init__(self, config):
        """Constructor.

        Args:
           config (dict)
             True if use of topography is enabled, False otherwise.
             Keys:
                 use_topography: Model uses topography
                 resolution_horiz: Horizontal resolution in m
        """
        self.elevation = None
        self.enabled = bool(config["use_topography"])
        self.resolution_horiz = float(config["resolution_horiz"]) if self.enabled else None
        self.resolution_vert = float(config["resolution_horiz"]) if self.enabled else None
        return

    def set_elevation(self, elev):
        """Set topography values.

        Args:
            elev (numpy.array)
                Numpy array [Nx*Ny] with elevation at points.
        """
        if not self.enabled:
            return
        
        self.elevation = elev
        return

    def generate_points(self, domain):
        """Generate points for topography.

        Args:
            domain (Model)
                Model with topography.
        Returns:
            2D array (Nx*Ny,2) of point locations for ground surface.
        """
        dx = self.resolution_horiz

        num_x = 1 + int(domain.dim_x / dx)
        num_y = 1 + int(domain.dim_y / dx)
        logger = logging.getLogger(__name__)
        logger.info("Topography contains {} points ({} x {}).".format(
            num_x*num_y, num_x, num_y))

        x1 = numpy.linspace(0.0, dx*(num_x-1), num_x)
        y1 = numpy.linspace(0.0, dx*(num_y-1), num_y)
        z1 = [0]
        x,y,z = numpy.meshgrid(x1, y1, z1)

        xyzG = numpy.vstack((x.ravel(), y.ravel(), z.ravel())).transpose()
        xyzP = numpy.zeros(xyzG.shape)
        azRad = domain.y_azimuth * math.pi / 180.0
        xyzP[:,0] = domain.origin_x + xyzG[:,0]*math.cos(azRad) + xyzG[:,1]*math.sin(azRad)
        xyzP[:,1] = domain.origin_y - xyzG[:,0]*math.sin(azRad) + xyzG[:,1]*math.cos(azRad)
        return xyzP
    

class HDF5Storage(object):
    """HDF5 file for storing gridded model.
    """

    def __init__(self, filename):
        """Constructor.

        Args:
            filename (str):
                Name for HDF5 file
        """
        self.filename = filename
        return

    def save_domain(self, domain):
        """Write domain attributes to HDF5 file.

        Args:
            domain (Model):
                Model domain.
        """
        DOMAIN_ATTRS = (
            "description",
            "version",
            "projection",
            "origin_x",
            "origin_y",
            "y_azimuth",
            "data_values",
            "data_units",
            "dim_x",
            "dim_y",
            "dim_z",
            )
        h5 = h5py.File(self.filename, "w")
        attrs = h5.attrs
        for attr in DOMAIN_ATTRS:
            attrs[attr] = getattr(domain, attr)
        h5.close()
        return

    def save_topography(self, topography):
        """Write topography to HDF5 file.

        Args:
            topography (Topography)
                Surface topography.
        """
        TOPOGRAPHY_ATTRS = (
            "ressolution_horiz",
            "resolution_vert",
            )
        
        h5 = h5py.File(self.filename, "w")
        topo_dataset = h5.create_dataset("topography", data=topography.elevation)
        attrs = topo_dataset.attrs
        for attr in DOMAIN_ATTRS:
            attrs[attr] = getattr(topography, attr)
        h5.close()
        return

    def load_topography(self):
        """Load topography from HDF5 file.

        Return:
            topography (Topography)
                Surface topography.
        """
        TOPOGRAPHY_ATTRS = (
            "ressolution_horiz",
            "resolution_vert",
            )
        h5 = h5py.File(self.filename, "r")
        topography = Topography()
        topo_dataset = h5["topography"]
        topography.elevation = topo_dataset[:]
        attrs = topo_dataset.attrs
        for attr in DOMAIN_ATTRS:
            setattr(topography, attr, attrs[attr])
        h5.close()        
        return topography
    
    def save_block(self, block, data):
        BLOCK_ATTRS = (
            "ressolution_horiz",
            "resolution_vert",
            "z_top",
            )
        h5 = h5py.File(self.filename, "w")
        block_dataset = h5.create_dataset(block.name, data=data)
        attrs = block_dataset.attrs
        for attr in BLOCK_ATTRS:
            attrs[attr] = getattr(block, attr)
        h5.close()
        return


class Model(ABC):
    """Georeferenced model composed of logical grids, potentially warped by topography.
    """
    
    def __init__(self, config):
        """Constructor.
        """
        self.topography = None
        self.blocks = []

        self.initialize(config)
        return

    def initialize(self, config):
        """Setup model, creating blocks.

        Args:
            config (dict)
                Model configuration.
        """
        self.description = config["geomodelgrids"]["description"]
        self.version = config["geomodelgrids"]["version"]
        self.projection = config["coordsys"]["projection"]
        self.origin_x = float(config["coordsys"]["origin_x"])
        self.origin_y = float(config["coordsys"]["origin_y"])
        self.y_azimuth = float(config["coordsys"]["y_azimuth"])
        self.data_values = config["data"]["values"]
        self.data_units = config["data"]["units"]
        self.dim_x = float(config["domain"]["dim_x"])
        self.dim_y = float(config["domain"]["dim_y"])
        self.dim_z = float(config["domain"]["dim_z"])
        
        self.config = config

        self.topography = Topography(config["topography"])
        for name in string_to_list(config["domain"]["blocks"]):
            block = Block(name, config[name])
            self.blocks.append(block)

        self.storage = HDF5Storage(config["geomodelgrids"]["filename"])
        return

    def import_domain(self):
        """Write domain information to storage."""
        self.storage.save_domain(self)
        return
    
    def import_topography(self):
        self.storage.save_topography(self.topography)
        return

    def load_topography(self):
        """Load topography from model file."""
        self.topography = self.storage.load_topography()
        return
    
    def import_block(self, block, values):
        self.storage.save_block(block, values)
        return

    #@abstractmethod
    def query_topography(self, points):
        pass
    
    #@abstractmethod
    def query_values(self, points):
        pass
    

class EarthVisionAPIModel(Model):

    def query_values(self, points):
        return

    def query_topography(self, points):
        POINTS_FILENAME = "topography_points.dat"
        ELEV_FILENAME = "topography_elev.dat"
        
        scale = length_units_to_scale(self.config["earthvision"]["topography_xy_units"])
        numpy.savetxt(POINTS_FILENAME, points/scale, fmt="%16.8e")
        
        topo_2grd = self.config["earthvision"]["topography_2grd"]
        cmd = "{filename_out}<elev> = bakint({ev2grd}, {filename_in}<x>, {filename_in}<y>);".format(
            filename_in=POINTS_FILENAME, filename_out=ELEV_FILENAME, ev2grd=topo_2grd)
        print(cmd)
        #subprocess.run(["ev_fp"], input=cmd)

        elev = numpy.loadtxt(ELEV_FILENAME)
        elev /= length_units_to_scale(self.config["earthvision"]["topography_units"])
        self.topography.set_elevation(elev)
        return


class App(object):
    """Application for generating a rasterized model.
    """

    def __init__(self):
        """Constructor."""
        self.config = None
        self.model = None
        return

    def main(self, **kwargs):
        """Main entry point.
        """
        args = argparse.Namespace(**kwargs) if kwargs else self._parse_command_line()
        logLevel = logging.DEBUG if args.debug else logging.INFO
        logging.basicConfig(level=logLevel, filename="rasterize.log")
        if args.show_progress:
            self.show_progress = True
        config = self.initialize(args.config)

        if args.show_parameters:
            self.show_parameters(config)
            return
        
        model = EarthVisionAPIModel(config)

        if args.import_domain:
            model.import_domain()

        if args.import_topography:
            if model.topography.enabled:
                points = model.topography.generate_points(model)
                model.query_topography(points)
                #model.import_topography()

        if args.import_blocks:
            if model.topography is None:
                model.load_topography()
            for block in model.blocks:
                points = block.generate_points(model)
                values = model.query_values(points)
                model.import_block(block, values)
        return
 
    def initialize(self, config_filenames):
        """Set parameters from config file and DEFAULTS.

        Args:
            config_filename (str)
                Name of configuration (INI) file with parameters.
        """
        config = configparser.ConfigParser()
        for filename in config_filenames.split(","):
            if not os.path.isfile(filename):
                raise IOError("Could not find configuration file '{}'.".format(filename))
            if self.show_progress:
                print("Fetching parameters from {}...".format(filename))
            config.read(filename)

        config = {s: dict(config.items(s)) for s in config.sections()}
        return config
    
    def show_parameters(self, config):
        """Write parameters to stdout.
        """
        parser = configparser.ConfigParser()
        parser.read_dict(config)
        parser.write(sys.stdout)
        return

    def _parse_command_line(self):
        """Parse command line arguments.
        """
        DESCRIPTION = (
            "Application for generating HDF5 file containing blocks of a grid-based model."
            )
        
        parser = argparse.ArgumentParser(description=DESCRIPTION)
        parser.add_argument("--config", action="store", dest="config", required=True)
        parser.add_argument("--show-parameters", action="store_true", dest="show_parameters")
        parser.add_argument("--import-domain", action="store_true", dest="import_domain")
        parser.add_argument("--import-topography", action="store_true", dest="import_topography")
        parser.add_argument("--import-blocks", action="store_true", dest="import_blocks")

        parser.add_argument("--all", action="store_true", dest="all")
        parser.add_argument("--quiet", action="store_false", dest="show_progress", default=True)
        parser.add_argument("--log", action="store", dest="log_filename", default="rasterize.log")
        parser.add_argument("--debug", action="store_true", dest="debug")
        args = parser.parse_args()

        if args.debug:
            logging.basicConfig(level=logging.DEBUG, filename=args.log_filename)
        else:
            logging.basicConfig(level=logging.INFO, filename=args.log_filename)
        return args


# ------------------------------------------------------------------------------
if __name__ == "__main__":
    App().main()


# End of file
